//AS3ExporterAIR version 2.3, code Flash 10, generated by Prefab3D: http://www.closier.nl/prefab
package tileset.end
{
	import away3d.containers.ObjectContainer3D;
	import away3d.containers.Scene3D;
	import away3d.materials.*;
	import away3d.core.base.*;
	import away3d.loaders.utils.*;
	import away3d.loaders.data.*;
	import flash.utils.Dictionary;
	import away3d.primitives.*;
	import flash.display.Bitmap;
	import flash.display.BitmapData;

	import flash.geom.*;

	public class End extends Mesh
	{
		[Embed(source="images/aw_0.jpg")]
		private var Aw_0_Bitmap_Bitmap:Class;

		private var objs:Object = {};
		private var geos:Array = [];
		private var oList:Array =[];
		private var aC:Array;
		private var aV:Array;
		private var aU:Array;
		private var _scale:Number;

		public function End(scale:Number = 1)
		{
			_scale = scale;
			setSource();
			addContainers();
			buildMeshes();
			buildMaterials();
			cleanUp();
		}

		private function buildMeshes():void
		{
			var m0:Matrix3D = new Matrix3D();
			m0.rawData = Vector.<Number>([1,0,0,0,0,1,0,0,0,0,1,0,0*_scale,0*_scale,0*_scale,1]);
			transform = m0;

			objs.obj0 = {name:"aw_0",  transform:m0, pivotPoint:new Vector3D(0,0,0), container:-1, bothsides:false, material:null, ownCanvas:false, pushfront:false, pushback:false};
			objs.obj0.geo=geos[0];

			var ref:Object;
			
			var j:int;
			var av:Array;
			var au:Array;
			var v0:Vertex;
			var v1:Vertex;
			var v2:Vertex;
			var u0:UV;
			var u1:UV;
			var u2:UV;
			var aRef:Vector.<Face>;
			for(var i:int = 0;i<1;++i){
				ref = objs["obj"+i];
				if(ref != null){
					this.type = ".as";
					this.bothsides = ref.bothsides;
					this.name = ref.name;
					this.pushfront = ref.pushfront;
					this.pushback = ref.pushback;
					this.ownCanvas = ref.ownCanvas;

					oList.push(this);
					this.transform = ref.transform;
					this.movePivot(ref.pivotPoint.x, ref.pivotPoint.y, ref.pivotPoint.z);
					if (ref.geo.geometry != null) {
						this.geometry = ref.geo.geometry;
						continue;
					}
					ref.geo.geometry = new Geometry();
					this.geometry = ref.geo.geometry;
					aRef = ref.geo.f;
					for(j = 0;j<aRef.length;++j){
						Face(aRef[j]).material = ref.material;
						ref.geo.geometry.addFace( Face(aRef[j]));
					}

				}
			}
		}

		private function setSource():void
		{
			var geo0vert:String ="1f3.9184e729ffe/190/1f3.3e7,1ea.1bcb4df1bfe/12c.00000000000006/-0.001,-2.c87e98752c09e-d/1f4/-0.001,-2.c87e98752c09e-d/1f4/12c,-c8.00000000000011/c7.5af3107a3ffa/1e8.1e8,-2.c87e98752c09e-d/-1f4/-64.002,-1f4/-1f4/-1f3.3e7,1f3.9184e729ffe/-1f4/-1f3.3e7,1f3.9184e729ffe/-1f4/1.88fe1d9e89fff,-1e2.187724f1c806/63.5af3107a3ffd/c7.5adbc8035802,-18f.9184e729fff/190/-0.001,-1f4/190/-1f3.3e7,1d8.4035d7ebcff1/-63.5af3107a3ffd/-c8.002,18f.9184e729fff/-63.5af3107a3ffd/18f.5ac47f8c7005,-1f4/190/1f3.3e7,-1e5.407bb15087fb/63.5af3107a3ffd/1f3.3e7,-1f4/-63.5af3107a3ffd/-1f3.3e7,-1e7.30ee49e39018/-1f4/-64.002,-1c5.484e094277fc/-63.5af3107a3ffd/-64.002,-1f4/-1f4/dc.30e,-97.5520f2c0403/-1f4/1e5.2861ae3a5ffc,-75.4d2009e08011/-176.83/1f3.3e7,-18f.9184e729fff/-c8/18f.5ac47f8c7005,1f3.9184e729ffe/-1f4/1f3.3e7,-2.c87e98752c09e-d/-63.5af3107a3ffd/1f3.3e7,1f3.9184e729ffe/-63.5af3107a3ffd/-1f3.3e7,1f3.9184e729ffe/190/-1f3.3e7,-64.00000000000009/190/-121.052,-12c.0000000000003/-1f4/c7.5adbc8035802";
			var geo0uvs:String ="0.0e1de/0.09913,0.0b617/0.2d5b8,0.30672/0.2e54c,0.31451/0.1963d,0.6f98d/0.9de07,0.7c4fb/0.90fcd,0.4e34d/0.9d2de,0.ca1d3/0.276c9,0.ec3cd/0.0ad61,0.a757c/0.0ad61,0.1abd/0.4a26,0.1ac1/0.88f1b,0.b5833/0.9e64f,0.d381f/0.9cc4f,0.1f699/0.7a098,0.2ceb3/0.f397,0.c75/0.7b461,0.4d1dc/0.30143,0.55e4b/0.0d3f9,0.e938/0.89641,0.91b15/0.9e1a3,0.d381f/0.7ae0a,0.d381f/0.5f5a5,0.12ddc/0.65316,0.bca99/0.7aa4c,0.e938/0.5e7d8,0.6e02d/0.5eefe,0.6e02d/0.6d3cc,0.e938/0.73f0b,0.4e2e0/0.5ec21,0.2c8bf/0.5dc5b,0.6e02d/0.c5a9,0.0acf5/0.5dbe4,0.0acf5/0.79449,0.0acf5/0.9b28e,0.37455/0.43bfa,0.532bb/0.517bc,0.0bece/0.517bc,0.a6a47/0.50d50,0.c94fe/0.4a63d,0.de5e8/0.3bc3d,0.eb96c/0.276de,0.179a1/0.51774";
			var geo0faces:String ="0,1,2,0,1,2,3,0,2,3,0,2,3,4,0,4,5,6,5,6,7,7,8,9,8,5,7,a,7,9,9,a,b,b,c,d,c,1,d,e,f,10,3,2,a,3,2,11,e,3,a,12,3,11,f,4,3,13,5,4,e,f,3,14,13,4,10,6,11,15,16,17,12,10,11,18,15,17,13,14,15,19,1a,1b,16,13,15,1c,19,1b,15,14,17,1b,1a,1d,c,d,8,e,10,1e,b,10,12,d,15,18,9,b,12,b,d,18,4,f,16,5,13,1c,4,18,d,5,1f,10,8,d,17,1e,10,1d,18,17,d,1f,1d,10,15,18,16,1b,1f,1c,4,16,18,5,1c,1f,c,8,7,e,1e,20,19,c,7,21,e,20,1a,1,c,22,f,e,19,1a,c,21,22,e,1b,b,a,23,24,11,a,2,1b,11,2,23,1b,2,1a,23,2,25,8,17,14,a,26,27,5,8,14,7,a,27,5,14,1c,7,27,28,5,1c,11,7,28,29,1c,14,13,28,27,2a,1c,13,11,28,2a,29,16,12,11,1c,18,17,13,16,11,19,1c,17,12,16,9,18,1c,b,5,11,6,7,29,8,18,15,17,1f,1b,1d,4,d,0,5,10,6,2,1,1a,2,1,25,1,0,d,f,6,10,1b,1a,b,23,25,24,9,f,e,b,13,14,a,9,e,c,b,14,f,9,16,13,b,1c";
			var geo0:FacesDefinition = new FacesDefinition();
			geo0.f = buildFaces( geo0faces.split(","),  buildVertices(read(geo0vert).split(",")), buildUVs(read(geo0uvs).split(",")) );
			geos.push(geo0);
		}

		private function buildFaces(aFaces:Array, vVerts:Vector.<Vertex>, vUVs:Vector.<UV>):Vector.<Face>
		{
			var vFaces:Vector.<Face> = new Vector.<Face>();
			var f:Face;
			for(var i:int = 0;i<aFaces.length;i+=6){
				f = new Face( vVerts[parseInt(aFaces[i], 16)],
									vVerts[parseInt(aFaces[i+1], 16)],
									vVerts[parseInt(aFaces[i+2], 16)],
									null,
									vUVs[parseInt(aFaces[i+3], 16)],
									vUVs[parseInt(aFaces[i+4], 16)],
									vUVs[parseInt(aFaces[i+5], 16)]);
				vFaces.push(f);
			}

			return vFaces;
		}

		private function buildVertices(aVerts:Array):Vector.<Vertex>
		{
			var tmpv:Array;
			var vVerts:Vector.<Vertex> = new Vector.<Vertex>();
			for(var i:int = 0;i<aVerts.length;i++){
				tmpv = aVerts[i].split("/");
				vVerts[i] = new Vertex( parseFloat(tmpv[0])*_scale, parseFloat(tmpv[1])*_scale, parseFloat(tmpv[2])*_scale  );
			}
			return vVerts;
		}

		private function buildUVs(aUvs:Array):Vector.<UV>
		{
			var tmpv:Array;
			var vUVs:Vector.<UV> = new Vector.<UV>();
			for(var i:int = 0;i<aUvs.length;++i){
				tmpv = aUvs[i].split("/");
				vUVs[i] = new UV(parseFloat(tmpv[0]), parseFloat(tmpv[1]));
			}

			return vUVs;
		}


		private function buildMaterials():void
		{
				var aw_0_Bitmap:Bitmap = new Aw_0_Bitmap_Bitmap();
				applyMaterialToMesh("aw_0", aw_0_Bitmap.bitmapData);

		}

		private function applyMaterialToMesh(id:String, bmd:BitmapData):void
		{
			for(var i:int;i<meshes.length;++i){
				if(meshes[i].name == id){
					if(!bmd){
						trace("Embed of "+id+" failed! Check source path or if CS4 call 911!");
					} else {
					meshes[i].material = new BitmapMaterial(bmd);
					}
					break;
				}
			}
		}

		private function cleanUp():void
		{
			for(var i:int = 0;i<1;++i){
				objs["obj"+i] == null;
			}
			aV = null;
			aU = null;
		}

		private function addContainers():void
		{}


		public function get meshes():Array
		{
			return oList;
		}


		private function read(str:String):String
		{
			var start:int= 0;
			var chunk:String;
			var end:int= 0;
			var dec:String = "";
			var charcount:int = str.length;
			for(var i:int = 0;i<charcount;++i){
				if (str.charCodeAt(i)>=44 && str.charCodeAt(i)<= 48 ){
					dec+= str.substring(i, i+1);
				}else{
					start = i;
					chunk = "";
					while(str.charCodeAt(i)!=44 && str.charCodeAt(i)!= 45 && str.charCodeAt(i)!= 46 && str.charCodeAt(i)!= 47 && i<=charcount){
						i++;
					}
					chunk = ""+parseInt("0x"+str.substring(start, i), 16 );
					dec+= chunk;
					i--;
				}
			}
			return dec;
		}

	}
}
class FacesDefinition
{
	import away3d.core.base.Face;
	import away3d.core.base.Geometry;
	public var f:Vector.<Face>;
	public var geometry:Geometry;
}